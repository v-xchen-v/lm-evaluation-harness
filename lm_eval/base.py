import abc
from typing import Iterable
import numpy as np
import random
import re
import os
import json
import hashlib
import datasets
from sqlitedict import SqliteDict
from tqdm import tqdm
import torch
import torch.nn.functional as F
from accelerate import find_executable_batch_size
from accelerate.utils import gather
from itertools import chain

from lm_eval.metrics import mean, weighted_perplexity, weighted_mean, bits_per_byte
from lm_eval import utils
from abc import abstractmethod

from accelerate.utils import gather, pad_across_processes
import math

class LM(abc.ABC):
    def __init__(self):
        self.cache_hook = CacheHook(None)

    @abstractmethod
    def loglikelihood(self, requests):
        """Compute log-likelihood of generating a continuation from a context.
        Downstream tasks should attempt to use loglikelihood instead of other
        LM calls whenever possible.

        :param requests: list
            A list of pairs (context, continuation)
            context: str
                Context string. Implementations of LM must be able to handle an
                empty context string.
            continuation: str
                The continuation over which log likelihood will be calculated. If
                there is a word boundary, the space should be in the continuation.
                For example, context="hello" continuation=" world" is correct.
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    @abstractmethod
    def loglikelihood_rolling(self, requests):
        """Compute full log-likelihood of a string, with no truncation, for perplexity computation
        - We will use the full max context length of the model.
        - For inputs that exceed the max context length, we divide the tokenized string into chunks of up to
        the max context length.
        - IMPORTANT: Each document's loglikelihood/perplexity is computed *separately*, unlike other implementations
          which may simply concatenate multiple documents together.
        - IMPORTANT: We maximize the amount of context for each prediction. Specifically, for inputs that we break into
          multiple chunks, the last input will still a full-sized context.
          Example:
            Input tokens: [ 0 1 2 3 4 5 6 7 8 9 ]
            Prefix: EOT
            Max context length: 4
            Resulting input/prediction pairs:

                INPUT:  EOT   0   1   2
                PRED:     0   1   2   3

                INPUT:    3   4   5   6
                PRED:     4   5   6   7

                INPUT:    5   6   7   8
                PRED:             8   9

          Observe that:
            1. Each token is predicted exactly once
            2. For the last pair, we provide the full context, but only score the last two tokens

        :param requests: list
            A list of strings
            string: str
                String for which we are computing per-toke  loglikelihood
        :return: list
            A list of pairs (logprob, isgreedy)
            logprob: float
                The log probability of `continuation`
            isgreedy:
                Whether `continuation` would be generated by greedy sampling from `context`
        """
        pass

    # TODO: Add an optional max length
    @abstractmethod
    def greedy_until(self, requests):
        """Generate greedily until a stopping sequence

        :param requests: list
            A list of pairs (context, until)
            context: str
                Context string
            until: [str]
                The string sequences to generate until. These string sequences
                may each span across multiple tokens, or may be part of one token.
        :return: list
            A list of strings continuation
            continuation: str
                The generated continuation.
        """
        pass

    @classmethod
    def create_from_arg_string(cls, arg_string, additional_config=None):
        additional_config = {} if additional_config is None else additional_config
        args = utils.simple_parse_args_string(arg_string)
        args2 = {k: v for k, v in additional_config.items() if v is not None}
        return cls(**args, **args2)

    def set_cache_hook(self, cache_hook):
        self.cache_hook = cache_hook


class BaseLM(LM):
    def __init__(self):
        super().__init__()
        self.batch_schedule = 1
        self.batch_sizes = {}
        self.max_batch_size = 512
        # if run in data parallel mode, the distributed_state will have value
        self.distributed_state = None

    @property
    @abstractmethod
    def eot_token_id(self):
        pass

    @property
    @abstractmethod
    def max_length(self):
        pass

    @property
    @abstractmethod
    def max_gen_toks(self):
        pass

    @property
    @abstractmethod
    def batch_size(self):
        pass

    @property
    @abstractmethod
    def device(self):
        pass

    @abstractmethod
    def tok_encode(self, string: str):
        pass

    @abstractmethod
    def tok_decode(self, tokens: Iterable[int]):
        pass

    @abstractmethod
    def _model_generate(self, context, max_length, eos_token_id):
        pass

    @abstractmethod
    def _model_call(self, inps):
        """
        inps: a torch tensor of shape [batch, sequence]
        the size of sequence may vary from call to call

        returns: a torch tensor of shape [batch, sequence, vocab] with the
        logits returned from the model
        """
        pass

    def _detect_batch_size(self, requests=None, pos=0):
        if requests:
            # if pos is None:
            #     sorted_requests = sorted(requests, key=lambda request: (len(request[1])+len(request[2])))
            #     _, context_enc, continuation_enc = sorted_requests[-1]
            # else:
            _, context_enc, continuation_enc = requests[pos]
            max_length = len(
                (context_enc + continuation_enc)[-(self.max_length + 1) :][:-1]
            )
        else:
            max_length = self.max_length

        # # if OOM, then halves batch_size and tries again
        batch_size = 1
        while True:
            try:
                # if self.distributed_state:
                #     test_batch = torch.ones((batch_size, max_length), device=self.distributed_state.device).long()
                # else:
                test_batch = torch.ones((batch_size, max_length), device=self.device).long()
                for _ in range(5):
                    _ = F.log_softmax(self._model_call(test_batch), dim=-1).cpu()

                batch_size *= 2
                print(f"detected batch_size: {batch_size} on {self.device}")
                utils.clear_torch_cache()
            except RuntimeError: # OOM
                batch_size //= 2
                break

        # if OOM, then halves batch_size and tries again
        # @find_executable_batch_size(starting_batch_size=self.max_batch_size)
        # def forward_batch(batch_size):
        #     test_batch = torch.ones((batch_size, max_length), device=self.device).long()
        #     for _ in range(5):
        #         _ = F.log_softmax(self._model_call(test_batch), dim=-1).cpu()
        #     return batch_size

        # batch_size = forward_batch()
        # utils.clear_torch_cache()
        
        # in the data parallel mode, assuming the GPUs have same VRAM, so that the batch_size on each GPU should be same, the actual batch_size of all GPUs is the detected_largest_batchsize on single GPU * n_gpu.
        if self.distributed_state:
            return batch_size * self.distributed_state.num_processes

        # temporarily make detected batch_size smaller to avoid OOM in some unexpected cases
        if batch_size > 8:
            batch_size //= 2

        if batch_size == 0:
            raise Exception("OOM with minimal batch_size:1")
        return batch_size

    # subclass must implement properties vocab_size, eot_token_id, max_gen_toks, batch_size, device, max_length.
    # TODO: enforce this somehow

    def _encode_pair(self, context, continuation):
        n_spaces = len(context) - len(context.rstrip())
        if n_spaces > 0:
            continuation = context[-n_spaces:] + continuation
            context = context[:-n_spaces]
        whole_enc = self.tok_encode(context + continuation)
        context_enc = self.tok_encode(context)
        context_enc_len = len(context_enc)
        continuation_enc = whole_enc[context_enc_len:]
        return context_enc, continuation_enc

    def loglikelihood(self, requests, disable_same_ctx_requests_grouping=True):
        new_reqs = []
        for context, continuation in requests:
            if context == "":
                # end of text as context
                context_enc, continuation_enc = [self.eot_token_id], self.tok_encode(
                    continuation
                )
            else:
                context_enc, continuation_enc = self._encode_pair(context, continuation)

            new_reqs.append(((context, continuation), context_enc, continuation_enc))

        return self._loglikelihood_tokens(new_reqs, disable_same_ctx_requests_grouping=disable_same_ctx_requests_grouping)

    def loglikelihood_rolling(self, requests):
        # TODO: Implement caching once we've confirmed the perplexity implementation

        # automatic batch size detection for vectorization
        adaptive_batch_size = None
        if self.batch_size == "auto":
            # using rolling window with maximum context
            print("Passed argument batch_size = auto. Detecting largest batch size")
            batch_size = self._detect_batch_size()
            print(f"Determined Largest batch size: {batch_size}")
            adaptive_batch_size = batch_size

        loglikelihoods = []
        for (string,) in tqdm(requests):
            rolling_token_windows = list(
                map(
                    utils.make_disjoint_window,
                    utils.get_rolling_token_windows(
                        token_list=self.tok_encode(string),
                        prefix_token=self.eot_token_id,
                        max_seq_len=self.max_length,
                        context_len=1,
                    ),
                )
            )

            rolling_token_windows = [(None,) + x for x in rolling_token_windows]

            # TODO: extract out this call so it only gets called once and also somehow figure out partial caching for
            # that
            string_nll = self._loglikelihood_tokens(
                rolling_token_windows,
                disable_tqdm=True,
                override_bs=adaptive_batch_size,
            )

            # discard is_greedy
            string_nll = [x[0] for x in string_nll]

            string_nll = sum(string_nll)
            loglikelihoods.append(string_nll)

        return loglikelihoods

    def _loglikelihood_tokens(self, requests, disable_same_ctx_requests_grouping, disable_tqdm=False, override_bs=None):
        if not disable_same_ctx_requests_grouping:
            print("[INFO] grouping requests with the same context and single continous token for efficiency")
        # TODO: implement some kind of efficient-request-middleware that lumps together requests with the same context
        res = []

        def _collate(x):
            # the negative sign on len(toks) sorts descending - this has a few advantages:
            # - time estimates will always be over not underestimates, which is more useful for planning
            # - to know the size of a batch when going through the list, you know the first one is always the batch
            #   padded context length. this is useful to simplify the batching logic and more importantly to make
            #   automatic adaptive batches much much easier to implement
            # - any OOMs will happen right away rather than near the end

            
            if  isinstance(x[2][0], list):
                toks = x[1] + x[2][0]
            else:
                toks = x[1] + x[2]
            return -len(toks), tuple(toks)

        # To avoid repeat logits calculation: zip the same model_call input request, ...Answer: A(B, C, D) to ...Answer: [A, B, C, D] and unzip conts later in answer calcution and caching step
        def group_conts_with_same_ctx(reqs):
            grouped_reqs = []
            dicpos = {} # {ctx: grouped_request_list_idx}
            for req in reqs:
                ctx_cnt_pos, ctx_toks_pos, cnt_toks_pos = 0, 1, 2
                ctx, cnt = req[ctx_cnt_pos] # (ctx, cnt)
                # ctx_toks = req[ctx_toks_pos] # []
                cnt_toks = req[cnt_toks_pos] # []
                if len(cnt_toks) != 1:
                    raise Exception("The continous token length should be 1 when using grouping same context requests for efficiency")
                if ctx in dicpos:
                    grouped_req_idx = dicpos[ctx]
                    if isinstance(grouped_reqs[grouped_req_idx][cnt_toks_pos][0], list):
                        grouped_reqs[grouped_req_idx] = list(grouped_reqs[grouped_req_idx])
                        grouped_reqs[grouped_req_idx][ctx_cnt_pos][1].append(cnt)
                        grouped_reqs[grouped_req_idx][cnt_toks_pos].append(cnt_toks)
                        grouped_reqs[grouped_req_idx] = tuple(grouped_reqs[grouped_req_idx])
                    else:
                        grouped_reqs[grouped_req_idx] = list(grouped_reqs[grouped_req_idx])
                        grouped_reqs[grouped_req_idx][ctx_cnt_pos] = (ctx, [grouped_reqs[grouped_req_idx][ctx_cnt_pos][1], cnt]) 
                        grouped_reqs[grouped_req_idx][cnt_toks_pos] = [grouped_reqs[grouped_req_idx][cnt_toks_pos], cnt_toks]
                        grouped_reqs[grouped_req_idx] = tuple(grouped_reqs[grouped_req_idx])
                else:
                    grouped_reqs.append(req)
                    dicpos[ctx] = len(grouped_reqs)-1
            return grouped_reqs
        
        if disable_same_ctx_requests_grouping:
            re_ord = utils.Reorderer(requests, _collate)
        else:
            grouped_requests = group_conts_with_same_ctx(requests)
            re_ord = utils.Reorderer(grouped_requests, _collate)

        reordered_requests = re_ord.get_reordered()
        n_reordered_requests = len(reordered_requests)

        # automatic (variable) batch size detection for vectorization
        # pull longest context sample from request
        def _batch_scheduler(pos):
            sched = pos // int(n_reordered_requests / self.batch_schedule)
            if sched in self.batch_sizes:
                return self.batch_sizes[sched]
            print(
                f"Passed argument batch_size = auto:{self.batch_schedule}. Detecting largest batch size"
            )
            if not self.distributed_state or self.distributed_state and self.distributed_state.is_main_process:
                self.batch_sizes[sched] = self._detect_batch_size(reordered_requests, pos)
            else:
                # distrbuted non main process
                self.batch_sizes[sched] = -1
            if self.distributed_state:
                # self.distributed_state.wait_for_everyone()
                batch_size = torch.tensor(self.batch_sizes[sched], device=self.distributed_state.device)
                gathered_batch_sizes = gather(batch_size).cpu()
                self.batch_sizes[sched]=int(gathered_batch_sizes[gathered_batch_sizes>0][0])
            print(f"Determined largest batch size: {self.batch_sizes[sched]}")
            return self.batch_sizes[sched]

        for chunk in utils.chunks(
            tqdm(reordered_requests, disable=disable_tqdm),
            n=self.batch_size
            if self.batch_size != "auto"
            else override_bs
            if override_bs is not None
            else 0,
            fn=_batch_scheduler
            if self.batch_size == "auto" and n_reordered_requests > 0 and not override_bs
            else None,
        ):
            inps = []
            cont_toks_list = []
            inplens = []

            padding_length = None

            # because vectorizing is annoying, we first convert each (context, continuation) pair to padded
            # tensors, then we pack them together into a batch, call the model, and then pick it all apart
            # again because vectorizing is annoying

            for _, context_enc, continuation_enc in chunk:
                # sanity check
                assert len(context_enc) > 0
                assert len(continuation_enc) > 0
                assert len(continuation_enc) <= self.max_length

                # how this all works:
                #          CTX      CONT
                # inp    0 1 2 3|4 5 6 7 8 9   <- last token is deleted by inp[:, :-1]
                # gpt2    \               \
                # logits   1 2 3|4 5 6 7 8 9   <- the ctx half gets tossed out by the
                # cont_toks      4 5 6 7 8 9      [:, -len(continuation_enc):, :self.vocab_size] slice

                # when too long to fit in context, truncate from the left
                cont = continuation_enc
                
                # if using grouped requests, use the first one in one group
                if not disable_same_ctx_requests_grouping: # same to isinstance(continuation_enc[0], list):
                    continuation_enc = continuation_enc[0] # the first one will be the same as others in one grouped requests after doing[:-1] later
                    
                inp = torch.tensor(
                    (context_enc + continuation_enc)[-(self.max_length + 1) :][:-1],
                    dtype=torch.long,
                ).to(self.device)
                (inplen,) = inp.shape


                # since in _collate we make sure length is descending, the longest is always the first one.
                padding_length = (
                    padding_length if padding_length is not None else inplen
                )

                # pad length from seq to padding_length
                inp = torch.cat(
                    [
                        inp,  # [seq]
                        torch.zeros(padding_length - inplen, dtype=torch.long).to(
                            inp.device
                        ),  # [padding_length - seq]
                    ],
                    dim=0,
                )

                inps.append(inp.unsqueeze(0))  # [1, padding_length]
                cont_toks_list.append(cont)
                inplens.append(inplen)

            batched_inps = torch.cat(inps, dim=0)  # [batch, padding_length]
            
            # common answer computing logic of distributed evaluation and no parallel evaluation
            def get_likelihood_ans(cache_key, logits, inp, inplen, cont_toks):
                # Slice to original seq length
                contlen = len(cont_toks)
                inplen = inplen + (logits.shape[0] - padding_length) # if "virtual tokens" (from prompt tuning) are added, inplen is larger
                logits = logits[inplen - contlen : inplen].unsqueeze(
                    0
                )  # [1, seq, vocab]

                # Check if per-token argmax is exactly equal to continuation
                greedy_tokens = logits.argmax(dim=-1)
                cont_toks = torch.tensor(cont_toks, dtype=torch.long).unsqueeze(
                    0
                )  # [1, seq]
                
                # move tensor to gpu for data parallel
                if self.distributed_state:
                    cont_toks = cont_toks.to(self.distributed_state.device)
                max_equal = (greedy_tokens == cont_toks).all()

                # Obtain log-probs at the corresponding continuation token indices
                # last_token_slice = logits[:, -1, :].squeeze(0).tolist()
                logits = torch.gather(logits, 2, cont_toks.unsqueeze(-1)).squeeze(
                    -1
                )  # [1, seq]

                # Answer: (log prob, is-exact-match)
                answer = (float(logits.sum()), bool(max_equal))

                # partial caching
                if cache_key is not None:
                    # if using data parallel, only one process should do the cache, otherwise it brings dulication and conflict
                    if self.distributed_state is None or self.distributed_state.is_main_process:
                        self.cache_hook.add_partial("loglikelihood", cache_key, answer)
                return answer
            
            if self.distributed_state:
                batch_length = len(batched_inps) # batch
                num_samples_per_process =  math.ceil(batch_length/self.distributed_state.num_processes)
                
                # padding inps if batch_length is not n x num_processes
                is_inps_need_padding = batch_length < num_samples_per_process*self.distributed_state.num_processes
                pad_length = num_samples_per_process*self.distributed_state.num_processes - batch_length
                if is_inps_need_padding:
                    batched_inps_pad = batched_inps[-1].repeat(pad_length, 1).to(self.distributed_state.device)
                    batched_inps = torch.cat((batched_inps, batched_inps_pad), dim=0)
                    chunk = chunk + [chunk[0]]*pad_length
                    inplens = inplens + [inplens[0]]*pad_length
                    cont_toks_list = cont_toks_list + [cont_toks_list[0]]*pad_length

                distributed_res = []
                # distribute input to different GPUs
                with self.distributed_state.split_between_processes(batched_inps) as distributed_batched_inps: # [batch_size/num_process, padding_length]
                    distributed_multi_logits = F.log_softmax(
                        self._model_call(distributed_batched_inps), dim=-1
                    )  # [batch_size/num_process, padding_length, vocab]

                    # gather result back from GPUs to the first one(takes too much memory, abandoned).
                    # gathered_multi_logits_gpu = gather(multi_logits_gpu).detach().cpu()
                    
                    # distributed splits, figure out distributes splits on each GPU
                    start_index = self.distributed_state.process_index * num_samples_per_process
                    end_index = start_index + num_samples_per_process
                    if (len(batched_inps) % self.distributed_state.num_processes != 0) and (self.distributed_state.process_index == self.distributed_state.num_processes - 1):
                        end_index = batch_length
                    distributed_chunk = chunk[start_index:end_index]
                    distributed_inplens = inplens[start_index:end_index]
                    disrtibuted_cont_toks_list = cont_toks_list[start_index:end_index]
                    
                    # calcuated answer
                    for (cache_key, _, _), distributed_logits, distrbuted_inp, distributed_inplen, distributed_cont_toks in zip(distributed_chunk, distributed_multi_logits, distributed_batched_inps, distributed_inplens, disrtibuted_cont_toks_list):
                        if not disable_same_ctx_requests_grouping: # the same as if isinstance(distributed_cont_toks[0], list)
                            for idx, unzipped_distributed_cont_tokens in enumerate(distributed_cont_toks):
                                ctx, cnt = (cache_key[0], cache_key[1][idx])
                                answer = get_likelihood_ans((ctx, cnt), distributed_logits, distrbuted_inp, distributed_inplen,unzipped_distributed_cont_tokens)
                                distributed_res.append(answer)
                        else:
                            answer = get_likelihood_ans(cache_key, distributed_logits, distrbuted_inp, distributed_inplen,distributed_cont_toks)
                            distributed_res.append(answer)
                        
                    # dispatch answer to distributed gpus and gather back to get full answer
                    distributed_log_probs = torch.tensor([item[0] for item in distributed_res], device=self.distributed_state.device)
                    distributed_is_exact_match=torch.tensor([item[1] for item in distributed_res], device=self.distributed_state.device)
                    
                    # gather will do on each GPU, later may limit it to main process to save unnecessary computation
                    gathered_log_probs = gather(distributed_log_probs).cpu()
                    gathered_is_exact_matchs = gather(distributed_is_exact_match).cpu()
                    gathered_res=[]
                    for(gathered_log_prob, gathered_is_exact_match) in zip(gathered_log_probs, gathered_is_exact_matchs):
                        answer = (float(gathered_log_prob), bool(gathered_is_exact_match))
                        gathered_res.append(answer)
                    
                    if is_inps_need_padding:
                        gathered_res = gathered_res[:-pad_length]
                    res += gathered_res
            else:
                multi_logits = F.log_softmax(
                        self._model_call(batched_inps), dim=-1
                    ).cpu()  # [batch, padding_length, vocab]
                
                for (cache_key, _, _), logits, inp, inplen, cont_toks in zip(
                    chunk, multi_logits, inps, inplens, cont_toks_list
                ):
                    if not disable_same_ctx_requests_grouping: # the same as if isinstance(cont_toks[0], list):
                        for idx, _ in enumerate(cont_toks):
                            ctx, cnt = (cache_key[0], cache_key[1][idx])
                            answer = get_likelihood_ans((ctx, cnt), logits, inp, inplen, _)
                            res.append(answer)
                    else:
                        answer = get_likelihood_ans(cache_key, logits, inp, inplen, cont_toks)
                        res.append(answer)

        if not disable_same_ctx_requests_grouping:
            def group_res(lst1, lst2):
                """ Reshape a list according to given multi list """
                last = 0
                res = []
                for ele in lst1:
                    res.append(lst2[last : last + len(ele)])
                    last += len(ele)
                    
                return res
            
            # group results as requests to get original order
            grouped_res = group_res([x[2] for x in grouped_requests], res)
            # flatten to ungrouped
            return list(chain.from_iterable(re_ord.get_original(grouped_res)))
        return re_ord.get_original(res)

    def greedy_until(self, requests):
        # TODO: implement fully general `until` that handles until that are
        #       multiple tokens or that span multiple tokens correctly

        # TODO: extract to TokenizedLM?
        res = []

        def _collate(x):
            # the negative sign on len(toks) sorts descending - this has a few advantages:
            # - time estimates will always be over not underestimates, which is more useful for planning
            # - to know the size of a batch when going through the list, you know the first one is always the batch
            #   padded context length. this is useful to simplify the batching logic and more importantly to make
            #   automatic adaptive batches much much easier to implement
            # - any OOMs will happen right away rather than near the end

            toks = self.tok_encode(x[0])
            return -len(toks), x[0]

        re_ord = utils.Reorderer(requests, _collate)

        warn_stop_seq = False
        for context, request_args in tqdm(re_ord.get_reordered()):
            until = request_args["until"]
            if isinstance(until, str):
                until = [until]

            if until:
                try:
                    (primary_until,) = self.tok_encode(until[0])
                except ValueError:
                    if not warn_stop_seq:
                        print(
                            "Warning: a primary stop sequence is multi-token! Will default to EOS token for this tokenizer. Consider using `hf-causal-experimental` for multi-token stop sequence support for the time being."
                        )
                        warn_stop_seq = True
                    primary_until = self.eot_token_id
            else:
                primary_until = None

            context_enc = torch.tensor(
                [self.tok_encode(context)[self.max_gen_toks - self.max_length :]]
            ).to(self.device)

            max_gen_tokens = min(
                self.max_gen_toks, request_args.get("max_length", self.max_gen_toks)
            )
            cont = self._model_generate(
                context_enc, context_enc.shape[1] + max_gen_tokens, primary_until
            )

            s = self.tok_decode(cont[0].tolist()[context_enc.shape[1] :])

            for term in until:
                s = s.split(term)[0]

            # partial caching
            self.cache_hook.add_partial("greedy_until", (context, until), s)

            res.append(s)

        return re_ord.get_original(res)


class Task(abc.ABC):
    """A task represents an entire benchmark including its dataset, problems,
    answers, and evaluation methods. See BoolQ for a simple example implementation

    A `doc` can be any python object which represents one instance of evaluation.
    This is usually a dictionary e.g.
        {"question": ..., "answer": ...} or
        {"question": ..., question, answer)
    """

    # The name of the `Task` benchmark as denoted in the HuggingFace datasets Hub
    # or a path to a custom `datasets` loading script.
    DATASET_PATH: str = None

    # The name of a subset within `DATASET_PATH`.
    DATASET_NAME: str = None

    def __init__(self, data_dir=None, cache_dir=None, download_mode=None):
        """
        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.download(data_dir, cache_dir, download_mode)
        self._training_docs = None
        self._fewshot_docs = None

    def download(self, data_dir=None, cache_dir=None, download_mode=None):
        """Downloads and returns the task dataset.
        Override this method to download the dataset from a custom API.

        :param data_dir: str
            Stores the path to a local folder containing the `Task`'s data files.
            Use this to specify the path to manually downloaded data (usually when
            the dataset is not publicly accessible).
        :param cache_dir: str
            The directory to read/write the `Task` dataset. This follows the
            HuggingFace `datasets` API with the default cache directory located at:
                `~/.cache/huggingface/datasets`
            NOTE: You can change the cache location globally for a given process
            by setting the shell environment variable, `HF_DATASETS_CACHE`,
            to another directory:
                `export HF_DATASETS_CACHE="/path/to/another/directory"`
        :param download_mode: datasets.DownloadMode
            How to treat pre-existing `Task` downloads and data.
            - `datasets.DownloadMode.REUSE_DATASET_IF_EXISTS`
                Reuse download and reuse dataset.
            - `datasets.DownloadMode.REUSE_CACHE_IF_EXISTS`
                Reuse download with fresh dataset.
            - `datasets.DownloadMode.FORCE_REDOWNLOAD`
                Fresh download and fresh dataset.
        """
        self.dataset = datasets.load_dataset(
            path=self.DATASET_PATH,
            name=self.DATASET_NAME,
            data_dir=data_dir,
            cache_dir=cache_dir,
            download_mode=download_mode,
        )

    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return False

    @abstractmethod
    def has_training_docs(self):
        """Whether the task has a training set"""
        pass

    @abstractmethod
    def has_validation_docs(self):
        """Whether the task has a validation set"""
        pass

    @abstractmethod
    def has_test_docs(self):
        """Whether the task has a test set"""
        pass

    def training_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def validation_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def test_docs(self):
        """
        :return: Iterable[obj]
            A iterable of any object, that doc_to_text can handle
        """
        return []

    def _process_doc(self, doc):
        """
        Override this to process (detokenize, strip, replace, etc.) individual
        documents. This can be used in a map over documents of a data split.
        E.g. `map(self._process_doc, self.dataset["validation"])`

        :return: dict
            The processed version of the specified `doc`.
        """
        return doc

    def fewshot_examples(self, k, rnd):
        if self._training_docs is None:
            self._training_docs = list(self.training_docs())

        return rnd.sample(self._training_docs, k)

    def doc_to_decontamination_query(self, doc):
        print(
            "Override doc_to_decontamination_query with document specific decontamination query."
        )
        assert False

    @abstractmethod
    def doc_to_text(self, doc):
        pass

    @abstractmethod
    def doc_to_target(self, doc):
        pass

    @abstractmethod
    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        pass

    @abstractmethod
    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        pass

    @abstractmethod
    def aggregation(self):
        """
        :returns: {str: [metric_score] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metric scores
        """
        pass

    @abstractmethod
    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        pass

    def fewshot_description(self):
        import warnings

        warnings.warn(
            "`fewshot_description` will be removed in futures versions. Pass "
            "any custom descriptions to the `evaluate` function instead.",
            DeprecationWarning,
        )
        return ""

    @utils.positional_deprecated
    def fewshot_context(
        self, doc, num_fewshot, provide_description=None, rnd=None, description=None
    ):
        """Returns a fewshot context string that is made up of a prepended description
        (if provided), the `num_fewshot` number of examples, and an appended prompt example.

        :param doc: str
            The document as returned from training_docs, validation_docs, or test_docs.
        :param num_fewshot: int
            The number of fewshot examples to provide in the returned context string.
        :param provide_description: bool
            Not implemented, and this option is deprecated and will be removed in a future version in favor of a different description providing method
        :param rnd: random.Random
            The pseudo-random number generator used to randomly sample examples.
            WARNING: This is currently a required arg although it's optionalized with a default `None`.
        :param description: str
            The task's description that will be prepended to the fewshot examples.
        :returns: str
            The fewshot context.
        """
        assert (
            rnd is not None
        ), "A `random.Random` generator argument must be provided to `rnd`"
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        description = description + "\n\n" if description else ""

        if num_fewshot == 0:
            labeled_examples = ""
        else:
            # for sets with no training docs, draw from other set *but ensure no overlap with current doc*
            if self.has_training_docs():
                fewshotex = self.fewshot_examples(k=num_fewshot, rnd=rnd)
            else:
                if self._fewshot_docs is None:
                    self._fewshot_docs = list(
                        self.validation_docs()
                        if self.has_validation_docs()
                        else self.test_docs()
                    )

                fewshotex = rnd.sample(self._fewshot_docs, num_fewshot + 1)

                # get rid of the doc that's the one we're evaluating, if it's in the fewshot
                fewshotex = [x for x in fewshotex if x != doc][:num_fewshot]

            labeled_examples = (
                "\n\n".join(
                    [
                        self.doc_to_text(doc) + self.doc_to_target(doc)
                        for doc in fewshotex
                    ]
                )
                + "\n\n"
            )

        example = self.doc_to_text(doc)
        return description + labeled_examples + example

class MultipleChoiceTask(Task):
    def doc_to_target(self, doc):
        return " " + doc["choices"][doc["gold"]]

    def construct_requests(self, doc, ctx):
        lls = [
            rf.loglikelihood(ctx, " {}".format(choice))[0] for choice in doc["choices"]
        ]

        return lls

    def process_results(self, doc, results):
        gold = doc["gold"]

        # logits_sum = [x[0] for x in results]
        
        acc = 1.0 if np.argmax(results) == gold else 0.0
        completion_len = np.array([float(len(i)) for i in doc["choices"]])
        acc_norm = 1.0 if np.argmax(results / completion_len) == gold else 0.0

        return {
            "acc": acc,
            "acc_norm": acc_norm,
        }

    def higher_is_better(self):
        return {
            "acc": True,
            "acc_norm": True,
        }

    def aggregation(self):
        return {
            "acc": mean,
            "acc_norm": mean,
        }

class GreedyGenerateOptionKeyTask(Task):
    """given the description, question and multiple options with format as below:
    -----------
    <prompt>
    A. <choice1>
    B. <choice2>
    C. <choice3>
    D. <choice4>
    Answer:
    -----------
    use greedy search decoding method to generate answer and expect right choice inside option keys."""
    def doc_to_target(self, doc):
        return " " + doc["choices"][doc["gold"]]
    
    def construct_requests(self, doc, ctx):
        lls = [
            rf.greedy_until(ctx, {"until": [], "max_length": None})
        ]

        return lls
    
    def doc_to_text(self, doc, circular_index=0):
        return self.format_example(doc["doc"], doc["choices"], circular_index)
    
    def process_results(self, doc, results):
        gold = doc["gold"]
        choices = doc["choices"]
        gold_choice = choices[gold]

        # list only have single element
        greedy_gen = results[0]
        pattern = r'[^a-zA-Z]'
        charactersonly_greedy_gen = re.sub(pattern, '', greedy_gen)
        greedy_is_exact_match = (charactersonly_greedy_gen.upper() == gold_choice.upper())
        
        
        return {
            "greedy_is_exact_match_acc": greedy_is_exact_match,
        }

    def higher_is_better(self):
        return {
            "greedy_is_exact_match_acc": True,
        }

    def aggregation(self):
        return {
            "greedy_is_exact_match_acc": mean,
        }

class GreedyGenerateAnswerTask(Task):
    """answer with greedy until generated continuous and compare the result of choices """
    def doc_to_target(self, doc):
        return " " + doc["choices"][doc["gold"]]
    
    def construct_requests(self, doc, ctx):
        lls = [
            rf.greedy_until(ctx, {"until": [], "max_length": None})
        ]

        return lls
    
    def process_results(self, doc, results, llm_judge_write_out_info):
        gold = doc["gold"]
        choices = doc["choices"]
        gold_choice = choices[gold]
        # acc = 1.0 if np.argmax(results) == gold else 0.0
        # completion_len = np.array([float(len(i)) for i in doc["choices"]])
        # acc_norm = 1.0 if np.argmax(results / completion_len) == gold else 0.0

        # list only have single element
        greedy_gen = results[0]
        
        # greedy_is_exact_match = (greedy_gen == gold_choice)
        
        # res = gpt_4_completion("prompt.txt", question="What is the meaning of life?", answer="42", choices="A. 42\nB. 43\nC. 44\nD. 45")
        from lm_eval.llmjudge.gpt4 import gpt_4_completion
        ret = gpt_4_completion(
            "prompt.txt", question=doc["query"], answer=greedy_gen, choices=doc["choices"]
        )
        
        # write llm judgement info to info json file
        llm_judge_write_out_info["llm_judge"] = {
            "question": doc["ctx"],
            "answer": greedy_gen,
            "choices": doc["choices"],
            "response": ret['response']}
        
        ret_ans = ret['response'].strip('"').strip('(').strip(')')
        if ret_ans == 'None' or ret_ans == 'There seems to be some confusion in your input. It appears there are two sets of questions and answers, but the second set is not correctly formatted. Could you please provide the correct format so I can assist you accurately?':
            greedy_is_gpt4_match = 0
        else:
            greedy_is_gpt4_match = (ord(ret_ans)-ord('A')==gold)
        
        return {
            # "greedy_is_exact_match_acc": greedy_is_exact_match,
            "greedy_is_gpt4_match_acc": greedy_is_gpt4_match,
        }

    def higher_is_better(self):
        return {
            # "greedy_is_exact_match_acc": True,
            "greedy_is_gpt4_match_acc": True,
        }

    def aggregation(self):
        return {
            # "greedy_is_exact_match_acc": mean,
            "greedy_is_gpt4_match_acc": mean,
        }

class LikelihoodOptionKeyMultipleCircularChoiceTask(MultipleChoiceTask):
    def construct_requests(self, doc, ctx: list):
        return self.construct_circularchoices_requests(doc, ctx)

    def construct_circularchoices_requests(self, doc, ctx):
        lls = []
        for circular_index, item in enumerate(ctx):
            for i in range(0, len(doc["choices"])):
                choice = doc["choices"][i]
                lls.append(rf.loglikelihood(item, " {}".format(choice))[0])
            # lls += [
            #     rf.loglikelihood(item, " {}".format(choice))[0] for choice in doc["choices"]
            # ]

        return lls

    def _format_subject(self, subject):
        words = subject.split("_")
        return " ".join(words)

    def doc_to_text(self, doc, circular_index=0):
        return self.format_example(doc["doc"], doc["choices"], circular_index)

    def process_results(self, doc, results):
        choice_size = len(doc["choices"])
        gold = doc["gold"]

        logits = np.array([x[0] for x in results]).reshape((len(doc["choices"]), -1))
        max_equals = np.array([x[1] for x in results]).reshape((len(doc["choices"]), -1))

        # the one with biggest probility is match the label, treat is as right
        circular_gold = np.array([((gold+i)%choice_size) for i in range(0, choice_size)])
        next_token_argmax_choices_circular_acc = 1.0 if np.all(np.argmax(logits, axis=-1) == circular_gold) else 0.0
        next_token_argmax_choices_acc = 1.0 if np.argmax(logits[0]) == gold else 0.0

        # the one fully match the label, treat it as right. If it has higgest probility but not exactly match treat it as not right.
        next_token_argmax_all_circular_acc = 1.0 if np.all(max_equals[np.arange(0, choice_size), circular_gold]) else 0.0
        next_token_argmax_all_acc = 1.0 if max_equals[0, gold] else 0.0
        
        
        completion_len = []
        choices_len = [float(len(i)) for i in doc["choices"]]
        for circular_index in range(0, len(doc["choices"])):
            completion_len += choices_len[circular_index:] + choices_len[:circular_index]
        completion_len = np.array(completion_len).reshape((len(doc["choices"]), -1))

        return {
            "next_token_argmax_choices_acc": next_token_argmax_choices_acc,
            "next_token_argmax_all_acc": next_token_argmax_all_acc,
            "next_token_argmax_choices_circular_acc": next_token_argmax_choices_circular_acc,
            "next_token_argmax_all_circular_acc": next_token_argmax_all_circular_acc
        }

    def aggregation(self):
        return {
            "next_token_argmax_choices_acc": mean,
            "next_token_argmax_all_acc": mean,
            "next_token_argmax_choices_circular_acc": mean,
            "next_token_argmax_all_circular_acc": mean,
        }
        
    def fewshot_context(
        self, doc, num_fewshot, circular_index, provide_description=None, rnd=None, description=None
    ):
        """Returns a fewshot context string that is made up of a prepended description
        (if provided), the `num_fewshot` number of examples, and an appended prompt example.

        :param doc: str
            The document as returned from training_docs, validation_docs, or test_docs.
        :param num_fewshot: int
            The number of fewshot examples to provide in the returned context string.
        :param provide_description: bool
            Not implemented, and this option is deprecated and will be removed in a future version in favor of a different description providing method
        :param rnd: random.Random
            The pseudo-random number generator used to randomly sample examples.
            WARNING: This is currently a required arg although it's optionalized with a default `None`.
        :param description: str
            The task's description that will be prepended to the fewshot examples.
        :returns: str
            The fewshot context.
        """
        assert (
            rnd is not None
        ), "A `random.Random` generator argument must be provided to `rnd`"
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        subject = self.DATASET_NAME
        if subject:
            description = f"The following are multiple choice questions (with answers) about {self._format_subject(subject)}."
        description = description + "\n\n" if description else ""

        if num_fewshot == 0:
            labeled_examples = ""
        else:
            fewshotex = self.fewshot_examples(k=num_fewshot, rnd=rnd)

            # labeled_examples = ""
            # for fewshot_idx, doc in enumerate(fewshotex):
            #       "Problem {}.   ".format(fewshot_idx + 1) + self.doc_to_text(doc, 0) + self.doc_to_target(doc) + "\n\n"
            labeled_examples = (
                "\n\n".join(
                    [
                        self.doc_to_text(doc) + self.doc_to_target(doc)
                        for doc in fewshotex
                    ]
                )
                + "\n\n"
            )


        example = self.doc_to_text(doc, circular_index)
        return description + labeled_examples + example
        # return self.doc_to_text(doc, num_fewshot)

class LikelihoodOptionContentMultipleChoiceTask(MultipleChoiceTask):
    def process_results(self, doc, results):
        gold = doc["gold"]

        # ppls = results
        acc = 1.0 if np.argmax(results) == gold else 0.0
        return {
            "ppl_argmax_acc": acc,
        }

    def higher_is_better(self):
        return {
            "ppl_argmax_acc": True,
        }

    def aggregation(self):
        return {
            "ppl_argmax_acc": mean,
        }
    
class PerplexityTask(Task, abc.ABC):
    def should_decontaminate(self):
        """Whether this task supports decontamination against model training set."""
        return True

    def has_training_docs(self):
        return False

    def fewshot_examples(self, k, rnd):
        assert k == 0
        return []

    def fewshot_context(
        self, doc, num_fewshot, provide_description=None, rnd=None, description=None
    ):
        assert (
            num_fewshot == 0
        ), "The number of fewshot examples must be 0 for perplexity tasks."
        assert (
            rnd is not None
        ), "A `random.Random` generator argument must be provided to `rnd`."
        assert not provide_description, (
            "The `provide_description` arg will be removed in future versions. To prepend "
            "a custom description to the context, supply the corresponding string via the "
            "`description` arg."
        )
        if provide_description is not None:
            # nudge people to not specify it at all
            print(
                "WARNING: provide_description is deprecated and will be removed in a future version in favor of description_dict"
            )

        return ""

    def higher_is_better(self):
        return {
            "word_perplexity": False,
            "byte_perplexity": False,
            "bits_per_byte": False,
        }

    def doc_to_decontamination_query(self, doc):
        return doc

    def doc_to_text(self, doc):
        return ""

    def doc_to_target(self, doc):
        return doc

    def construct_requests(self, doc, ctx):
        assert not ctx
        req = rf.loglikelihood_rolling(self.doc_to_target(doc))
        return req

    def process_results(self, doc, results):
        (loglikelihood,) = results
        words = self.count_words(doc)
        bytes_ = self.count_bytes(doc)
        return {
            "word_perplexity": (loglikelihood, words),
            "byte_perplexity": (loglikelihood, bytes_),
            "bits_per_byte": (loglikelihood, bytes_),
        }

    def aggregation(self):
        return {
            "word_perplexity": weighted_perplexity,
            "byte_perplexity": weighted_perplexity,
            "bits_per_byte": bits_per_byte,
        }

    @classmethod
    def count_bytes(cls, doc):
        return len(doc.encode("utf-8"))

    @classmethod
    def count_words(cls, doc):
        """Downstream tasks with custom word boundaries should override this!"""
        return len(re.split(r"\s+", doc))


def hash_args(attr, args):
    dat = json.dumps([attr] + list(args))
    return hashlib.sha256(dat.encode("utf-8")).hexdigest()


class CacheHook:
    def __init__(self, cachinglm):
        if cachinglm is None:
            self.dbdict = None
            return

        self.dbdict = cachinglm.dbdict

    def add_partial(self, attr, req, res):
        if self.dbdict is None:
            return
        hsh = hash_args(attr, req)
        self.dbdict[hsh] = res


class CachingLM:
    def __init__(self, lm, cache_db):
        """LM wrapper that returns cached results if they exist, and uses the underlying LM if not.

        :param lm: LM
            Underlying LM
        :param cache_db: str
            Path to cache db
        """
        self.lm = lm
        self.cache_db = cache_db
        if os.path.dirname(cache_db):
            os.makedirs(os.path.dirname(cache_db), exist_ok=True)
        self.dbdict = SqliteDict(cache_db, autocommit=True)

        # add hook to lm
        lm.set_cache_hook(self.get_cache_hook())

    def __getattr__(self, attr):
        lm_attr = getattr(self.lm, attr)
        if not callable(lm_attr):
            return lm_attr

        def fn(requests):
            res = []
            remaining_reqs = []

            # figure out which ones are cached and which ones are new
            for req in requests:
                hsh = hash_args(attr, req)
                if hsh in self.dbdict:
                    ob = self.dbdict[hsh]

                    assert ob is not None

                    res.append(ob)
                else:
                    res.append(None)
                    remaining_reqs.append(req)

            # actually run the LM on the requests that do not have cached results
            rem_res = getattr(self.lm, attr)(remaining_reqs)

            # stick the new ones back into the list and also cache any of the new ones
            resptr = 0
            for req, r in zip(remaining_reqs, rem_res):
                while res[resptr] is not None:
                    resptr += 1

                res[resptr] = r

                # caching
                hsh = hash_args(attr, req)
                self.dbdict[hsh] = r
            self.dbdict.commit()

            return res

        return fn

    def get_cache_hook(self):
        return CacheHook(self)


REQUEST_RETURN_LENGTHS = {
    "loglikelihood": 2,
    "greedy_until": None,
    "loglikelihood_rolling": None,
}


class Request:
    def __init__(self, request_type, args, index=None):
        if request_type not in REQUEST_RETURN_LENGTHS.keys():
            raise NotImplementedError(
                "The request type {} is not implemented!".format(request_type)
            )

        self.request_type = request_type
        self.args = args
        self.index = index

    def __iter__(self):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        for i in range(REQUEST_RETURN_LENGTHS[self.request_type]):
            yield Request(self.request_type, self.args, i)

    def __getitem__(self, i):
        if REQUEST_RETURN_LENGTHS[self.request_type] is None:
            raise IndexError("This request type does not return multiple arguments!")
        return Request(self.request_type, self.args, i)

    def __eq__(self, other):
        return (
            self.request_type == other.request_type
            and self.args == other.args
            and self.index == other.index
        )

    def __repr__(self):
        return f"Req_{self.request_type}{self.args}[{self.index}]\n"


class RequestFactory:
    def __getattr__(self, attr):
        def fn(*args):
            return Request(attr, args)

        return fn


rf = RequestFactory()
